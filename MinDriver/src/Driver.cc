#include <cctk.h>
#include <cctk_Schedule.h>
#include <cctki_ScheduleBindings.h>
#include <cctki_GHExtensions.h>
#include <cctk_Parameters.h>
#include <iostream>
#include <assert.h>
#include <map>
#include <vector>

#define HERE { std::cout << "here " << __FILE__ << ":" << __LINE__ << std::endl; }

const char *where = "MyEvolve";

const char *ExtensionName = "MyDriver";

/**
 * Every driver thorn extends the cGH data strcuture in some way.
 * In this, most basic of thorns, I only keep track of how many
 * time levels have previously been allocated for a grid variable.
 */
struct MyDriverData {
    std::map<int,int> time_levels;
};

int GroupStorageCrease(const cGH *cctkGH, int n_groups, const int *groups,
                       const int *requested_tls, int *status);

int CallFunction(void *function,           ///< the function to call
                 cFunctionData *attribute, ///< attributes of the function
                 void *data) ///< private data for CCTK_CallFunction
{
    std::cout << "Calling: " << attribute->thorn << "::" << attribute->routine << " {" << std::endl;
    int const res = CCTK_CallFunction(function, attribute, data);
    std::cout << "}" << std::endl;
    return res;
}

/**
 * This is just here to test the scheduling mechanism.
 */
extern "C"
void evol_here(CCTK_ARGUMENTS)
{
    DECLARE_CCTK_ARGUMENTS_evol_here;
    std::cout << "Evolution is working "<< std::endl;
}

void ScheduleTraverse(char const *const where, char const *const name,
                      cGH *const cctkGH) {
  CCTK_ScheduleTraverse(name, cctkGH, CallFunction);
}

/**
 * The driver writer is responsible for calling the following
 * schedule bins in the order specified by the static output
 * generated by the flesh.
 */
int Evolve(tFleshConfig *const fc) 
{
    int conv_level = 0;
    cGH *cctkGH = fc->GH[conv_level];
    std::cout << "Evolve" << std::endl;
    ScheduleTraverse(where, "CCTK_PREREGRID", cctkGH);
    // do regrid
    ScheduleTraverse(where, "CCTK_POSTREGRID", cctkGH);
    // rotate time levels
    // t -> t + dt
    ScheduleTraverse(where, "CCTK_PRESTEP", cctkGH);
    ScheduleTraverse(where, "CCTK_EVOL", cctkGH);
    // Evolve finer grids recursively
    // Restrict from finer grids
    ScheduleTraverse(where, "CCTK_POSTRESTRICT", cctkGH);
    ScheduleTraverse(where, "CCTK_POSTSTEP", cctkGH);
    ScheduleTraverse(where, "CCTK_CHECKPOINT", cctkGH);
    // OutputGH
    ScheduleTraverse(where, "CCTK_ANALYSIS", cctkGH);
    return 0;
}

cGH *InstantiateGH(tFleshConfig *const fc,int conv_level)
{
    DECLARE_CCTK_PARAMETERS;

    cGH *thisGH = new cGH();
    std::cout << "cGH=" << thisGH << std::endl;
    thisGH->cctk_dim = CCTK_MaxGFDim();
    CCTKi_SetupGHExtensions(fc, conv_level, thisGH);

    /* Need this to be at least one otherwise the memory allocation will fail */
    int cctk_dim = thisGH->cctk_dim;
    if (thisGH->cctk_dim == 0)
      cctk_dim = 1;
    thisGH->cctk_iteration    = 0;
    thisGH->cctk_gsh          = new int[cctk_dim];
    thisGH->cctk_lsh          = new int[cctk_dim];
    thisGH->cctk_lbnd         = new int[cctk_dim];
    thisGH->cctk_ubnd         = new int[cctk_dim];
    thisGH->cctk_tile_min     = new int[cctk_dim];
    thisGH->cctk_tile_max     = new int[cctk_dim];

    thisGH->cctk_ash          = new int[cctk_dim];
    thisGH->cctk_to           = new int[cctk_dim];
    thisGH->cctk_from         = new int[cctk_dim];
    thisGH->cctk_bbox         = new int[2*cctk_dim];
    thisGH->cctk_nghostzones  = new int[2*cctk_dim];
    thisGH->cctk_levfac       = new int[cctk_dim];
    thisGH->cctk_levoff       = new int[cctk_dim];
    thisGH->cctk_levoffdenom  = new int[cctk_dim];
    thisGH->cctk_delta_space  = new CCTK_REAL8[cctk_dim];
    thisGH->cctk_origin_space = new CCTK_REAL8[cctk_dim];

    thisGH->cctk_delta_time = 1;
    thisGH->cctk_timefac = 1;
    thisGH->cctk_convlevel = 0;
    thisGH->data = new void**[CCTK_NumVars()];

    // Multipatch is not currently handled.
    assert(not CCTK_IsFunctionAliased("MultiPatch_GetDomainSpecification"));

    // It is simpler to assume that CartGrid3D is here.
    assert(CCTK_IsThornActive("CartGrid3D"));

    int type;
    void const *const ptr = CCTK_ParameterGet("type", "CartGrid3D", &type);
    assert(ptr != 0);
    assert(type == PARAMETER_KEYWORD);
    char const *const coordtype = *static_cast<char const *const *>(ptr);
    if (not CCTK_EQUALS(coordtype, "coordbase")) {
        CCTK_ERROR("CartGrid3D is active. Please also set "
                   "CartGrid3D::type = \"coordbase\"");
    }

    typedef double real3d[3];

    real3d physical_min, physical_max;
    real3d interior_min, interior_max;
    real3d exterior_min, exterior_max;
    real3d base_spacing;

    int ierr = GetDomainSpecification(
        cctk_dim, &physical_min[0], &physical_max[0], &interior_min[0],
        &interior_max[0], &exterior_min[0], &exterior_max[0], &base_spacing[0]);
    assert(not ierr);

    // Set the values in the lsh and ash arrays
    for(int i=0;i < cctk_dim;i++) {
        thisGH->cctk_ash[i] =
            std::ceil((exterior_max[i] - exterior_min[i])/base_spacing[i]);
        thisGH->cctk_lsh[i] =
            std::ceil((interior_max[i] - interior_min[i])/base_spacing[i]);
    }

    return thisGH;
}

/**
 * Allocate the extension containing data used by the driver.
 */
void *MySetupGH(tFleshConfig *fc, int convLevel, cGH *cgh)
{
    return new MyDriverData();
}

/**
 * Not sure what this is needed for. But it's here.
 */
int MyInitGH(cGH *cgh)
{
    return 0;
}

int Initialise(tFleshConfig *const fc) 
{
    DECLARE_CCTK_PARAMETERS;

    int conv_level = 0;

    // We must initialize the cGH here. Borrow the default routine.
    cGH *cctkGH = InstantiateGH(fc, conv_level);
    fc->GH = new cGH*[1];
    fc->GH[0] = cctkGH;

    /* Initialise time */
    cctkGH->cctk_time = *(const CCTK_REAL *)
                  CCTK_ParameterGet ("cctk_initial_time", "Cactus", NULL);

    /* Initialise iteration number */
    cctkGH->cctk_iteration = 0;

    // The extension doesn't get setup without these
    CCTKi_ScheduleGHInit(cctkGH);
    CCTKi_InitGHExtensions(cctkGH);

    // Ask for the extension we allocated above
    MyDriverData *md = (MyDriverData *)CCTK_GHExtension(cctkGH, ExtensionName);
    assert(md != nullptr);

    ScheduleTraverse(where, "CCTK_WRAGH", cctkGH);
    ScheduleTraverse(where, "CCTK_PARAMCHECK", cctkGH);
    if(fc->recovered) {
        ScheduleTraverse(where, "CCTK_BASEGRID", cctkGH);
        ScheduleTraverse(where, "CCTK_RECOVER_VARIABLES", cctkGH);
        ScheduleTraverse(where, "CCTK_POST_RECOVER_VARIABLES", cctkGH);
    } else {
        ScheduleTraverse(where, "CCTK_PREREGRIDINITIAL", cctkGH);
        // setup grid hierarchy
        // Post
        ScheduleTraverse(where, "CCTK_PREREGRIDINITIAL", cctkGH);
        ScheduleTraverse(where, "CCTK_BASEGRID", cctkGH);
        ScheduleTraverse(where, "CCTK_INITIAL", cctkGH);
        ScheduleTraverse(where, "CCTK_POSTINITIAL", cctkGH);
        // initialize finer grids recursively
        ScheduleTraverse(where, "CCTK_POSTRESTRICTINITIAL", cctkGH);
        ScheduleTraverse(where, "CCTK_POSTPOSTINITIAL", cctkGH);
        ScheduleTraverse(where, "CCTK_POSTSTEP", cctkGH);
        ScheduleTraverse(where, "CCTK_CPINITIAL", cctkGH);
    }
    ScheduleTraverse(where, "CCTK_ANALYSIS", cctkGH);
    // OutputGH happens here
    return 0;
}

int Shutdown(tFleshConfig *const fc) 
{
    int conv_level = 0;
    cGH *cctkGH = fc->GH[conv_level];
    ScheduleTraverse(where, "CCTK_TERMINATE", cctkGH);
    //free(&cctkGH[0]); <-- wrong, causes double free
    delete cctkGH;
    ScheduleTraverse(where, "CCTK_SHUTDOWN", nullptr);
    return 0;
}

/**
 * The requested number of tls are supplied for both increase and
 * decrease, so why not just have one function for both?
 */
int GroupStorageCrease(const cGH *cctkGH, int n_groups, const int *groups,
                       const int *requested_tls, int *status) {
    assert(cctkGH->data != nullptr);
    std::cout << "Calling De/Increase...\n";
    for(int i=0;i<n_groups;i++) {
        int ntls = requested_tls[i];
        int const group = groups[i];
        int const declared_tls = CCTK_DeclaredTimeLevelsGI(group);
        if(ntls < declared_tls)
            ntls = declared_tls;

        int otls = 0;
        bool init = false;
        MyDriverData *md = (MyDriverData *)CCTK_GHExtension(cctkGH, ExtensionName);
        assert(md != nullptr);
        auto fgroup = md->time_levels.find(group);
        if(fgroup == md->time_levels.end()) {
            // There are no old time levels. This is the
            // first allocation.
            init = true;
        } else {
            otls = fgroup->second;
        }
        if(otls == ntls) {
            return 0;
        }
        // Update our extension
        md->time_levels[group] = ntls;

        cGroup gp;
        int ierr = CCTK_GroupData(group, &gp);
        assert(ierr == 0);
        int const firstvarindex = CCTK_FirstVarIndexI(group);

        // For every group
        for(int v=0;v<gp.numvars;v++) {

            int varindex = v + firstvarindex;

            // For every variable in that group...
            for(int j=0;j<ntls;j++) {

                void **new_data = new void*[ntls];

                int m = std::min(otls,ntls);

                // Copy old variable data into the new array
                for(int i=0;i<m;i++) {
                    new_data[i] = cctkGH->data[varindex][i];
                }

                for(int i=m;i<ntls;i++) {
                    int dims = cctkGH->cctk_dim;
                    unsigned int sz = cctkGH->cctk_ash[dims-1];
                    sz = 1;
                    int gtype = CCTK_GroupTypeI(group);
                    int vtype = CCTK_VarTypeI(varindex);
                    int gsize = CCTK_VarTypeSize(vtype);

                    // Someething went wrong...
                    if(gsize <= 0) {
                        std::cout << "gtype=" << gtype << std::endl;
                        std::cout << "gsize=" << gsize << std::endl;
                        std::cout << "name=" << CCTK_FullGroupName(group) << std::endl;
                    }
                    assert(gsize > 0);

                    sz *= gsize;

                    // todo
                    assert(gtype != CCTK_ARRAY);

                    if(gtype == CCTK_GF) {
                        for(int dim=0;dim < dims;dim++) {
                            assert(cctkGH->cctk_ash[dim] > 0);
                            sz *= cctkGH->cctk_ash[dim];
                        }
                    }

                    // Not necessary to allocate data as longs
                    // but I'm choosing to do so.
                    while((sz % sizeof(long)) != 0)
                        sz++;
                    new_data[i] = new long[sz/sizeof(long)];
                }

                // If the time levels are decreasing, free the
                // previously allocated data.
                for(int i=m;i<otls;i++)
                    delete[]  ((long*)cctkGH->data[varindex][i]);

                if(!init) {
                    delete[] cctkGH->data[varindex];
                }

                // update the time-level storage array for the variable
                cctkGH->data[varindex] = new_data;
            }
        }
    }
    return 0;
}

// Not sure what this does.
int QueryGroupStorageB(const cGH *cctkGH, int group, const char *groupname) {
    return 0;
}

extern "C"
int Driver_Startup()
{
  CCTK_RegisterBanner("This is a Custom Driver");

  CCTK_OverloadEvolve(Evolve);
  CCTK_OverloadInitialise(Initialise);
  CCTK_OverloadShutdown(Shutdown);

  CCTK_OverloadGroupStorageIncrease(GroupStorageCrease);
  CCTK_OverloadGroupStorageDecrease(GroupStorageCrease);

  CCTK_OverloadQueryGroupStorageB(QueryGroupStorageB);

  int GHExtension = CCTK_RegisterGHExtension(ExtensionName);
  CCTK_RegisterGHExtensionSetupGH(GHExtension, MySetupGH);
  CCTK_RegisterGHExtensionInitGH(GHExtension, MyInitGH);
  std::cout << "Registered Extension: " << ExtensionName << std::endl;

  // Other things we could initialize...
  #if 0
  CCTK_OverloadOutputGH(OutputGH);

  CCTK_OverloadSyncGroupsByDirI(SyncGroupsByDirI);

  // Don't need these two, older, call the next two
  CCTK_OverloadEnableGroupStorage(EnableGroupStorage);
  CCTK_OverloadDisableGroupStorage(DisableGroupStorage);

  // Need these two
  CCTK_OverloadGroupStorageIncrease(GroupStorageIncrease);
  CCTK_OverloadGroupStorageDecrease(GroupStorageDecrease);

  // Max number that were ever active
  CCTK_OverloadQueryMaxTimeLevels(QueryMaxTimeLevels);

  // Not really used
  CCTK_OverloadEnableGroupComm(EnableGroupComm);
  CCTK_OverloadDisableGroupComm(DisableGroupComm);

  CCTK_OverloadBarrier(Barrier);
  // CCTK_OverloadNamedBarrier (NamedBarrier);

  CCTK_OverloadExit((int (*)(cGH *, int))Exit);
  CCTK_OverloadAbort((int (*)(cGH *, int))Abort);

  CCTK_OverloadMyProc(MyProc);
  CCTK_OverloadnProcs(nProcs);

  // Return the size of a grid array in a particular format for Fortran
  CCTK_OverloadArrayGroupSizeB(ArrayGroupSizeB);
  // Whether a group has storage or not?
  CCTK_OverloadQueryGroupStorageB(QueryGroupStorageB);

  // Fill in lsh, etc. when grids change size
  // Sam and Roland did this for CarpetX
  CCTK_OverloadGroupDynamicData(GroupDynamicData);

  // Global constant for the number of dimensions? Global parameter?
  #endif

  return 0;
}
